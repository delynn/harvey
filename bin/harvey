#!/usr/bin/env node

var _ = require('underscore');
var path = require('path');
var pkg = require('../package.json');
var async = require('async');
var commandLine = require('commander');
var path = require('path');
var glob = require('glob');
var reporterFactory = require('../lib/reporters/reporterFactory.js');
var Harvey = require('../index.js');
var harvey = new Harvey();
var color = require('cli-color');
var options = getCommandLineArguments();
var testSuiteFileNames = getTestSuiteFiles(options.args);
var testSuiteDatas = loadTestSuiteDatas(testSuiteFileNames);
var config = loadJson(options.configFile);
var actions = parseActionPaths(options.actions);

var parallelTests = [];
var timeStarted = new Date();
var reporter = (options.reporter === 'none') ? null : reporterFactory.createReporter(options.reporter || 'console');


for(var i=0; i<actions.length; i++) {
	harvey.addCustomAction(actions[i].name, actions[i].location);
}

testSuiteDatas.forEach(function(testSuiteData) {
	if (options.testId) {
		testSuiteData.tests = filterTestsById(testSuiteData.tests, options.testId);
	}
	parallelTests.push(function(cb) {
		launchHarvey(testSuiteData, config, cb);
	});
});


async.parallel(parallelTests, function(error, results) {
	if (error) {
		fail(error);
	}
	var totalTestsFailed = 0,
		totalTestsExecuted = 0,
		totalTestsSkipped = 0;
	results.forEach(function(result) {
		totalTestsFailed += result.testsFailed;
		totalTestsExecuted += result.testsExecuted;
		totalTestsSkipped += result.testsSkipped;
	});

	if (!reporter) {
		process.exit(totalTestsFailed);
	}
	var overallResults = {
		timeStarted: timeStarted,
		timeEnded: new Date(),
		testsExecuted: totalTestsExecuted,
		testsFailed: totalTestsFailed,
		testsSkipped: totalTestsSkipped,
		suiteResults: results
	};
	reporter.reportResults(overallResults, config, function(error) {
		process.exit(totalTestsFailed);
	});

});

function launchHarvey(testSuiteData, config, callback) {
	var suiteStarted = new Date();
	harvey.run(testSuiteData, config, function(error, suiteResult) {
		if (error) {
			return callback(error);
		}

		var stats = getTestStats(suiteResult);

		var results = {
			"suiteId": testSuiteData.id,
			"suiteName": testSuiteData.name,
			"timeStarted": suiteStarted,
			"timeEnded": new Date(),
			"testsExecuted": stats.testsExecuted,
			"testsFailed": stats.testsFailed,
			"testsSkipped": stats.testsSkipped,
			"validationsPerformed": stats.validationsPerformed,
			"validationsFailed": stats.validationsFailed,
			"testResults": suiteResult
		};
		callback(null, results);
	});
}

function getCommandLineArguments() {

	commandLine
		.version(pkg.version)
		.option('-d, --debug', 'Shows stack traces when errors are received')
		.option('-c, --configFile <path>', 'The path to the config file')
		.option('-r, --reporter <console|json|html|none>', 'Which reporter to use for displaying the results. Defaults to console.')
		.option('--test-id <testId>', 'The id of a single test to run')
		.option('--actions <actions>', 'A comma delimited list of paths to custom actions')
		.parse(process.argv);

	return commandLine;
}

function getTestSuiteFiles(arguments) {

	if (!arguments.length) {
		fail("No test suite files were specified");
	}
	var fileNames = [];
	arguments.forEach(function(pattern) {
		glob.sync(pattern).forEach(function(file) {
			if (path.extname(file) !== '.json') {
				fail('Invalid test suite file "' + file + '". Test suites must be defined in a JSON file.');
			}
			fileNames.push(file);
		});
	});
	if (!fileNames.length) {
		fail("No test suite files found");
	}

	return fileNames;
}

function loadTestSuiteDatas(fileNames) {
	var data = [],
		suiteIds = [];
	fileNames.forEach(function(fileName) {
		var suite = loadJson(fileName);
		suite.id = suite.id || fileName;
		suite.name = suite.name || path.basename(fileName, '.json');

		if (suiteIds.indexOf(suite.id) >= 0) {
			fail('More than one test suite has an ID of "' + suite.id + '". Test suite ID\'s must be unique')
		}
		suiteIds.push(suite.id);
		data.push(suite);
	});

	return data;
}

function loadJson(filename) {
	if (!filename) return {};

	filename = path.resolve(filename);

	try {
		var data = require(filename);
	} catch (e) {
		fail("Unable to load file '" + filename + "': " + e);
	}

	return data;
}

function getTestStats(suiteResults) {
	var stats = {
		"testsExecuted": 0,
		"testsFailed": 0,
		"testsSkipped": 0,
		"validationsPerformed": 0,
		"validationsFailed": 0
	};

	for (var i = 0; i < suiteResults.suiteStepResults.length; i++) {
		if (_.isArray(suiteResults.suiteStepResults[i])) {
			var testResults = suiteResults.suiteStepResults[i];
			for (var j = 0; j < testResults.length; j++) {
				var testResult = testResults[j];
				if (testResult.skipped) {
					stats.testsSkipped++;
				} else {
					stats.testsExecuted++;
					if (!testResult.passed) stats.testsFailed++;

					for (var k = 0; k < testResult.testStepResults.length; k++) {
						var testStepResult = testResult.testStepResults[k];

						for (var l = 0; l < testStepResult.validationResults.length; l++) {
							var validationResult = testStepResult.validationResults[l];
							stats.validationsPerformed++;
							if (!validationResult.valid) stats.validationsFailed++;
						}

					}
				}
			}
		}
	}
	

	return stats;
}

function filterTestsById(tests, testId) {

	var filteredTests = [];

	for (var i = 0; i < tests.length; i++) {
		if (testId === tests[i].id) {
			filteredTests.push(tests[i]);
			break;
		}
	}

	return filteredTests;
}

function parseActionPaths(actionPathsString) {
	var actions = [];
	actionPathsString = actionPathsString || "";

	var actionPaths = actionPathsString.split(',');

	for(var i=0; i<actionPaths.length; i++) {
		//The action path will either be in the for some/dir/sampleAction.js
		// or just sampleAction.js.  We need to parse the name, 'sample', out of it

		var path = actionPaths[i];
		var startingPos = path.lastIndexOf('/') + 1;

		name = path.substring(startingPos);
		name = name.replace('Action.js', '');

		//Add the new action object to the array
		actions.push({
			"name": name,
			"location": path
		});
	}

	return actions;
}

function fail(error) {
	if (!(error instanceof Error)) {
		// give all error messages a stack trace for debug purposes
		error = new Error(error);
	}

	if (options.debug) {
		console.error(color.red(error.stack));
	}
	else {
		console.error(color.red(error.message));
	}
	process.exit(1);
}